/**
 * LinguaTube Subtitle Fetching Service - TypeScript Interfaces
 * Defines internal subtitle format and service types for fetching and parsing subtitle content
 */

// ========================================
// Core Subtitle Data Types
// ========================================

/**
 * Time representation for subtitle segments
 */
export interface SubtitleTime {
  readonly hours: number;
  readonly minutes: number;
  readonly seconds: number;
  readonly milliseconds: number;
}

/**
 * Core subtitle segment with timing and content
 */
export interface SubtitleSegment {
  readonly id: string;
  readonly startTime: number; // seconds with millisecond precision
  readonly endTime: number; // seconds with millisecond precision
  readonly text: string;
  readonly originalText?: string; // for translations
  readonly styling?: SubtitleStyling;
  readonly position?: SubtitlePosition;
  readonly metadata?: SubtitleSegmentMetadata;
}

/**
 * Text styling for subtitle segments
 */
export interface SubtitleStyling {
  readonly bold?: boolean;
  readonly italic?: boolean;
  readonly underline?: boolean;
  readonly color?: string;
  readonly backgroundColor?: string;
  readonly fontSize?: string;
  readonly fontFamily?: string;
  readonly alignment?: 'left' | 'center' | 'right';
}

/**
 * Position information for subtitle segments
 */
export interface SubtitlePosition {
  readonly line?: number | string;
  readonly position?: number | string;
  readonly size?: number | string;
  readonly align?: 'start' | 'middle' | 'end';
  readonly vertical?: 'rl' | 'lr';
}

/**
 * Additional metadata for subtitle segments
 */
export interface SubtitleSegmentMetadata {
  readonly speaker?: string;
  readonly language?: string;
  readonly confidence?: number; // 0-1 for auto-generated subtitles
  readonly region?: string;
  readonly notes?: string[];
  readonly tags?: string[];
}

// ========================================
// Subtitle Container Types
// ========================================

/**
 * Complete subtitle file data
 */
export interface SubtitleFile {
  readonly id: string;
  readonly segments: SubtitleSegment[];
  readonly metadata: SubtitleFileMetadata;
  readonly format: SubtitleFormat;
  readonly cacheInfo?: SubtitleCacheInfo;
}

/**
 * Metadata for the entire subtitle file
 */
export interface SubtitleFileMetadata {
  readonly title?: string;
  readonly language: string;
  readonly languageCode: string;
  readonly duration?: number; // total duration in seconds
  readonly segmentCount: number;
  readonly source: SubtitleSource;
  readonly encoding?: string;
  readonly framerate?: number;
  readonly createdAt?: number;
  readonly modifiedAt?: number;
  readonly author?: string;
  readonly description?: string;
  readonly detectedFormat?: SubtitleFormat;
}

/**
 * Source information for subtitles
 */
export interface SubtitleSource {
  readonly type: 'youtube' | 'upload' | 'generated' | 'manual' | 'vtt' | 'srt' | 'text';
  readonly url?: string;
  readonly videoId?: string;
  readonly trackId?: string;
  readonly isAutoGenerated: boolean;
  readonly fetchedAt: number;
}

/**
 * Cache information for subtitle files
 */
export interface SubtitleCacheInfo {
  readonly cacheKey: string;
  readonly cachedAt: number;
  readonly expiresAt: number;
  readonly size: number; // bytes
  readonly etag?: string;
  readonly lastModified?: string;
}

// ========================================
// Subtitle Format Types
// ========================================

/**
 * Supported subtitle formats
 */
export enum SubtitleFormat {
  SRT = 'srt',
  VTT = 'vtt',
  WEBVTT = 'webvtt',
  ASS = 'ass',
  SSA = 'ssa',
  TTML = 'ttml',
  SBV = 'sbv',
  YOUTUBE_XML = 'youtube_xml',
  YOUTUBE_SRV1 = 'youtube_srv1',
  YOUTUBE_SRV2 = 'youtube_srv2',
  YOUTUBE_SRV3 = 'youtube_srv3',
  JSON = 'json',
  PLAIN_TEXT = 'plain_text',
}

/**
 * Format detection result
 */
export interface FormatDetectionResult {
  readonly format: SubtitleFormat;
  readonly confidence: number; // 0-1
  readonly indicators: string[]; // what indicated this format
}

// ========================================
// Fetching Service Types
// ========================================

/**
 * Subtitle fetch request configuration
 */
export interface SubtitleFetchRequest {
  readonly url: string;
  readonly format?: SubtitleFormat;
  readonly language?: string;
  readonly headers?: Record<string, string>;
  readonly timeout?: number;
  readonly useCache?: boolean;
  readonly cacheKey?: string;
  readonly retryConfig?: RetryConfig;
}

/**
 * General fetch configuration for HTTP requests
 */
export interface FetchConfig {
  readonly timeout?: number;
  readonly headers?: Record<string, string>;
  readonly retries?: number;
  readonly userAgent?: string;
  readonly cache?: boolean;
}

/**
 * Retry configuration for failed requests
 */
export interface RetryConfig {
  readonly maxAttempts: number;
  readonly baseDelay: number; // milliseconds
  readonly maxDelay: number; // milliseconds
  readonly exponentialBackoff: boolean;
  readonly retryOn?: number[]; // HTTP status codes to retry
}

/**
 * Default retry configuration
 */
export const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxAttempts: 3,
  baseDelay: 1000,
  maxDelay: 10000,
  exponentialBackoff: true,
  retryOn: [408, 429, 500, 502, 503, 504],
};

/**
 * Subtitle fetch result
 */
export interface SubtitleFetchResult {
  readonly success: boolean;
  readonly subtitleFile?: SubtitleFile;
  readonly error?: SubtitleFetchError;
  readonly fromCache: boolean;
  readonly fetchTime: number; // milliseconds
  readonly responseSize: number; // bytes
}

/**
 * Subtitle fetch error details
 */
export interface SubtitleFetchError {
  readonly code: SubtitleErrorCode;
  readonly message: string;
  readonly httpStatus?: number;
  readonly originalError?: unknown;
  readonly retryable: boolean;
  readonly retryAfter?: number; // seconds
}

/**
 * Error codes for subtitle operations
 */
export enum SubtitleErrorCode {
  // Network errors
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT = 'TIMEOUT',
  RATE_LIMITED = 'RATE_LIMITED',
  HTTP_ERROR = 'HTTP_ERROR',

  // CORS and permission errors
  CORS_ERROR = 'CORS_ERROR',
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',

  // Content errors
  NOT_FOUND = 'NOT_FOUND',
  INVALID_URL = 'INVALID_URL',
  INVALID_FORMAT = 'INVALID_FORMAT',
  PARSE_ERROR = 'PARSE_ERROR',
  EMPTY_CONTENT = 'EMPTY_CONTENT',

  // Cache errors
  CACHE_ERROR = 'CACHE_ERROR',
  CACHE_FULL = 'CACHE_FULL',

  // Processing errors
  CONVERSION_ERROR = 'CONVERSION_ERROR',
  MERGE_ERROR = 'MERGE_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',

  // Extension and system errors
  EXTENSION_ERROR = 'EXTENSION_ERROR',
  CONTENT_SCRIPT_ERROR = 'CONTENT_SCRIPT_ERROR',
  CONFIG_ERROR = 'CONFIG_ERROR',
  PROXY_ERROR = 'PROXY_ERROR',
  QUOTA_EXCEEDED = 'QUOTA_EXCEEDED',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
}

// ========================================
// Parsing Service Types
// ========================================

/**
 * Parser configuration
 */
export interface ParserConfig {
  readonly format: SubtitleFormat;
  readonly encoding?: string;
  readonly strict?: boolean;
  readonly mergeSegments?: boolean;
  readonly maxSegmentGap?: number; // seconds
  readonly preserveFormatting?: boolean;
}

/**
 * Parser result
 */
export interface ParseResult {
  readonly success: boolean;
  readonly segments?: SubtitleSegment[];
  readonly metadata?: Partial<SubtitleFileMetadata>;
  readonly errors?: ParseError[];
  readonly warnings?: ParseWarning[];
}

/**
 * Parser error
 */
export interface ParseError {
  readonly line?: number;
  readonly column?: number;
  readonly message: string;
  readonly code: string;
  readonly severity: 'error' | 'warning';
}

/**
 * Parser warning
 */
export interface ParseWarning extends ParseError {
  readonly suggestion?: string;
}

// ========================================
// Cache Service Types
// ========================================

/**
 * Cache configuration
 */
export interface CacheConfig {
  readonly maxSize: number; // bytes
  readonly maxFiles: number;
  readonly defaultTTL: number; // seconds
  readonly cleanupInterval: number; // seconds
  readonly storageType: 'memory' | 'persistent' | 'hybrid';
  readonly compressionEnabled: boolean;
}

/**
 * Cache entry
 */
export interface CacheEntry {
  readonly key: string;
  readonly data: SubtitleFile;
  readonly metadata: CacheEntryMetadata;
}

/**
 * Cache entry metadata
 */
export interface CacheEntryMetadata {
  readonly createdAt: number;
  readonly expiresAt: number;
  readonly lastAccessed: number;
  readonly accessCount: number;
  readonly size: number;
  readonly compressed: boolean;
  readonly etag?: string;
}

/**
 * Cache statistics
 */
export interface CacheStats {
  readonly totalSize: number;
  readonly totalFiles: number;
  readonly hitRate: number;
  readonly missRate: number;
  readonly evictionCount: number;
  readonly lastCleanup: number;
}

// ========================================
// Service Interfaces
// ========================================

/**
 * Main subtitle fetching service interface
 */
export interface SubtitleFetcher {
  fetchSubtitles(request: SubtitleFetchRequest): Promise<SubtitleFetchResult>;
  detectFormat(content: string): FormatDetectionResult;
  parseSubtitles(content: string, config: ParserConfig): Promise<ParseResult>;
  getCacheStats(): CacheStats;
  clearCache(): Promise<void>;
  preloadSubtitles(urls: string[]): Promise<void>;
}

/**
 * Subtitle parser interface
 */
export interface SubtitleParser {
  readonly format: SubtitleFormat;
  parse(content: string, config?: Partial<ParserConfig>): Promise<ParseResult>;
  serialize(segments: SubtitleSegment[], metadata?: Partial<SubtitleFileMetadata>): string;
  validate(content: string): boolean;
  detectFormat(content: string): number; // confidence 0-1
}

/**
 * Cache service interface
 */
export interface SubtitleCache {
  get(key: string): Promise<CacheEntry | null>;
  set(key: string, data: SubtitleFile, ttl?: number): Promise<void>;
  delete(key: string): Promise<boolean>;
  clear(): Promise<void>;
  getStats(): CacheStats;
  cleanup(): Promise<void>;
}

// ========================================
// Utility Types
// ========================================

/**
 * Time conversion utilities type
 */
export interface TimeUtils {
  parseTime(timeString: string): number;
  formatTime(seconds: number, format?: 'srt' | 'vtt' | 'human'): string;
  timeToSeconds(time: SubtitleTime): number;
  secondsToTime(seconds: number): SubtitleTime;
  validateTimeRange(start: number, end: number): boolean;
}

/**
 * Segment merging configuration
 */
export interface MergeConfig {
  readonly maxGap: number; // seconds
  readonly minDuration: number; // seconds
  readonly maxDuration: number; // seconds
  readonly preserveSpeakers: boolean;
  readonly mergeStrategy: 'time' | 'speaker' | 'content';
}

/**
 * Export configuration for different formats
 */
export interface ExportConfig {
  readonly format: SubtitleFormat;
  readonly includeMetadata: boolean;
  readonly preserveFormatting: boolean;
  readonly encoding?: string;
  readonly lineEnding?: '\n' | '\r\n';
  readonly includeEmptySegments: boolean;
}

// ========================================
// Constants
// ========================================

/**
 * Default cache configuration
 */
export const DEFAULT_CACHE_CONFIG: CacheConfig = {
  maxSize: 50 * 1024 * 1024, // 50MB
  maxFiles: 100,
  defaultTTL: 3600, // 1 hour
  cleanupInterval: 300, // 5 minutes
  storageType: 'hybrid',
  compressionEnabled: true,
};

/**
 * Default parser configuration
 */
export const DEFAULT_PARSER_CONFIG: Partial<ParserConfig> = {
  strict: false,
  mergeSegments: false,
  maxSegmentGap: 2.0,
  preserveFormatting: true,
};

/**
 * Default fetch timeout
 */
export const DEFAULT_FETCH_TIMEOUT = 30000; // 30 seconds

/**
 * Supported MIME types for subtitle formats
 */
export const SUBTITLE_MIME_TYPES: Record<SubtitleFormat, string> = {
  [SubtitleFormat.SRT]: 'text/srt',
  [SubtitleFormat.VTT]: 'text/vtt',
  [SubtitleFormat.WEBVTT]: 'text/vtt',
  [SubtitleFormat.ASS]: 'text/x-ass',
  [SubtitleFormat.SSA]: 'text/x-ssa',
  [SubtitleFormat.TTML]: 'application/ttml+xml',
  [SubtitleFormat.SBV]: 'text/x-sbv',
  [SubtitleFormat.YOUTUBE_XML]: 'application/xml',
  [SubtitleFormat.YOUTUBE_SRV1]: 'application/xml',
  [SubtitleFormat.YOUTUBE_SRV2]: 'application/xml',
  [SubtitleFormat.YOUTUBE_SRV3]: 'application/xml',
  [SubtitleFormat.JSON]: 'application/json',
  [SubtitleFormat.PLAIN_TEXT]: 'text/plain',
};
