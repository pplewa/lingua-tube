/**
 * YouTube Subtitle Discovery Module - TypeScript Interfaces
 * Defines types for parsing YouTube pages and extracting subtitle information
 */

// ========================================
// YouTube Player Response Types
// ========================================

/**
 * Structure of ytInitialPlayerResponse captions data
 */
export interface YTPlayerCaptions {
  playerCaptionsTracklistRenderer?: {
    captionTracks?: YTCaptionTrackRaw[];
    audioTracks?: YTAudioTrack[];
    translationLanguages?: YTTranslationLanguage[];
    defaultAudioTrackIndex?: number;
  };
}

/**
 * Raw caption track from YouTube's ytInitialPlayerResponse
 */
export interface YTCaptionTrackRaw {
  baseUrl: string;
  name: {
    simpleText: string;
    runs?: Array<{ text: string }>;
  };
  vssId: string;
  languageCode: string;
  kind?: string;
  rtl?: boolean;
  isTranslatable?: boolean;
}

/**
 * Audio track information from YouTube
 */
export interface YTAudioTrack {
  captionTrackIndices?: number[];
  defaultCaptionTrackIndex?: number;
  visibility?: string;
  hasDefaultTrack?: boolean;
  hasSharedCaptions?: boolean;
  audioTrackId?: string;
}

/**
 * Translation language option
 */
export interface YTTranslationLanguage {
  languageCode: string;
  languageName: {
    simpleText: string;
    runs?: Array<{ text: string }>;
  };
}

// ========================================
// Processed Subtitle Track Types
// ========================================

/**
 * Processed and normalized subtitle track information
 */
export interface SubtitleTrack {
  readonly id: string;
  readonly languageCode: string;
  readonly languageName: string;
  readonly baseUrl: string;
  readonly kind: SubtitleKind;
  readonly isAutoGenerated: boolean;
  readonly isTranslatable: boolean;
  readonly isRightToLeft: boolean;
  readonly vssId: string;
  readonly confidence?: number; // For auto-generated tracks
}

/**
 * Types of subtitle tracks available on YouTube
 */
export enum SubtitleKind {
  CAPTIONS = 'captions',        // Standard captions
  ASR = 'asr',                  // Automatic Speech Recognition
  FORCED = 'forced',            // Forced subtitles (for foreign language parts)
  UNKNOWN = 'unknown'           // Fallback for unrecognized types
}

/**
 * Language information with metadata
 */
export interface LanguageInfo {
  readonly code: string;        // ISO 639-1 language code
  readonly name: string;        // Human-readable name
  readonly nativeName?: string; // Name in the language itself
  readonly isRightToLeft: boolean;
  readonly isSupported: boolean; // Whether LinguaTube supports this language
}

// ========================================
// Discovery Service Types
// ========================================

/**
 * Result of subtitle discovery operation
 */
export interface SubtitleDiscoveryResult {
  readonly success: boolean;
  readonly tracks: SubtitleTrack[];
  readonly availableLanguages: LanguageInfo[];
  readonly videoId?: string;
  readonly videoTitle?: string;
  readonly error?: SubtitleDiscoveryError;
  readonly timestamp: number;
}

/**
 * Errors that can occur during subtitle discovery
 */
export interface SubtitleDiscoveryError {
  readonly code: SubtitleErrorCode;
  readonly message: string;
  readonly details?: Record<string, unknown>;
  readonly recoverable: boolean;
}

/**
 * Error codes for subtitle discovery
 */
export enum SubtitleErrorCode {
  PLAYER_NOT_LOADED = 'PLAYER_NOT_LOADED',
  PLAYER_RESPONSE_MISSING = 'PLAYER_RESPONSE_MISSING',
  CAPTIONS_NOT_AVAILABLE = 'CAPTIONS_NOT_AVAILABLE',
  PARSING_FAILED = 'PARSING_FAILED',
  INVALID_VIDEO_PAGE = 'INVALID_VIDEO_PAGE',
  NETWORK_ERROR = 'NETWORK_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
}

// ========================================
// Discovery Service Configuration
// ========================================

/**
 * Configuration for subtitle discovery behavior
 */
export interface SubtitleDiscoveryConfig {
  readonly retryAttempts: number;
  readonly retryDelay: number;
  readonly observerTimeout: number;
  readonly prioritizeLanguages: string[]; // Language codes in order of preference
  readonly includeAutoGenerated: boolean;
  readonly includeTranslatable: boolean;
  readonly enableFallbacks: boolean;
}

/**
 * Default configuration values
 */
export const DEFAULT_DISCOVERY_CONFIG: SubtitleDiscoveryConfig = {
  retryAttempts: 3,
  retryDelay: 1000,
  observerTimeout: 10000,
  prioritizeLanguages: ['en', 'es', 'fr', 'de'],
  includeAutoGenerated: true,
  includeTranslatable: true,
  enableFallbacks: true,
};

// ========================================
// Discovery Service Interface
// ========================================

/**
 * Events emitted by the subtitle discovery service
 */
export enum SubtitleDiscoveryEvent {
  TRACKS_DISCOVERED = 'tracks_discovered',
  TRACKS_UPDATED = 'tracks_updated', 
  DISCOVERY_FAILED = 'discovery_failed',
  PLAYER_LOADED = 'player_loaded',
  VIDEO_CHANGED = 'video_changed',
}

/**
 * Event data structure
 */
export interface SubtitleDiscoveryEventData<T = unknown> {
  readonly type: SubtitleDiscoveryEvent;
  readonly data: T;
  readonly videoId?: string;
  readonly timestamp: number;
}

/**
 * Main subtitle discovery service interface
 */
export interface SubtitleDiscoveryService {
  // Core discovery methods
  discoverSubtitles(): Promise<SubtitleDiscoveryResult>;
  getAvailableSubtitleTracks(): Promise<SubtitleTrack[]>;
  getSubtitleTrackByLanguage(languageCode: string): Promise<SubtitleTrack | null>;
  getPreferredSubtitleTrack(languageCodes: string[]): Promise<SubtitleTrack | null>;
  
  // Track analysis
  isAutoGenerated(track: SubtitleTrack): boolean;
  isTranslatable(track: SubtitleTrack): boolean;
  getTrackQuality(track: SubtitleTrack): 'high' | 'medium' | 'low';
  
  // Page monitoring
  startMonitoring(): void;
  stopMonitoring(): void;
  isMonitoring(): boolean;
  
  // Event handling
  addEventListener(type: SubtitleDiscoveryEvent, listener: (event: SubtitleDiscoveryEventData) => void): void;
  removeEventListener(type: SubtitleDiscoveryEvent, listener: (event: SubtitleDiscoveryEventData) => void): void;
  
  // Configuration
  updateConfig(config: Partial<SubtitleDiscoveryConfig>): void;
  getConfig(): SubtitleDiscoveryConfig;
  
  // Utility
  getCurrentVideoId(): string | null;
  getCurrentVideoTitle(): string | null;
  isVideoPage(): boolean;
  refresh(): Promise<SubtitleDiscoveryResult>;
}

// ========================================
// Parser Types
// ========================================

/**
 * Result of parsing ytInitialPlayerResponse
 */
export interface PlayerResponseParseResult {
  readonly success: boolean;
  readonly captions?: YTPlayerCaptions;
  readonly videoDetails?: YTVideoDetails;
  readonly error?: string;
  readonly rawResponse?: any;
}

/**
 * YouTube video details from player response
 */
export interface YTVideoDetails {
  readonly videoId: string;
  readonly title: string;
  readonly lengthSeconds: string;
  readonly channelId: string;
  readonly isLive?: boolean;
  readonly isUpcoming?: boolean;
}

/**
 * YouTube page context information
 */
export interface YouTubePageContext {
  readonly isVideoPage: boolean;
  readonly videoId?: string;
  readonly playlistId?: string;
  readonly timestamp?: number;
  readonly url: string;
}

// ========================================
// Utility Types
// ========================================

/**
 * Language mapping for common YouTube language codes
 */
export const YOUTUBE_LANGUAGE_MAP: Record<string, LanguageInfo> = {
  'en': { code: 'en', name: 'English', nativeName: 'English', isRightToLeft: false, isSupported: true },
  'es': { code: 'es', name: 'Spanish', nativeName: 'Español', isRightToLeft: false, isSupported: true },
  'fr': { code: 'fr', name: 'French', nativeName: 'Français', isRightToLeft: false, isSupported: true },
  'de': { code: 'de', name: 'German', nativeName: 'Deutsch', isRightToLeft: false, isSupported: true },
  'it': { code: 'it', name: 'Italian', nativeName: 'Italiano', isRightToLeft: false, isSupported: true },
  'pt': { code: 'pt', name: 'Portuguese', nativeName: 'Português', isRightToLeft: false, isSupported: true },
  'ru': { code: 'ru', name: 'Russian', nativeName: 'Русский', isRightToLeft: false, isSupported: true },
  'ja': { code: 'ja', name: 'Japanese', nativeName: '日本語', isRightToLeft: false, isSupported: true },
  'ko': { code: 'ko', name: 'Korean', nativeName: '한국어', isRightToLeft: false, isSupported: true },
  'zh': { code: 'zh', name: 'Chinese', nativeName: '中文', isRightToLeft: false, isSupported: true },
  'ar': { code: 'ar', name: 'Arabic', nativeName: 'العربية', isRightToLeft: true, isSupported: true },
  'hi': { code: 'hi', name: 'Hindi', nativeName: 'हिन्दी', isRightToLeft: false, isSupported: true },
  'tr': { code: 'tr', name: 'Turkish', nativeName: 'Türkçe', isRightToLeft: false, isSupported: true },
  'pl': { code: 'pl', name: 'Polish', nativeName: 'Polski', isRightToLeft: false, isSupported: true },
  'nl': { code: 'nl', name: 'Dutch', nativeName: 'Nederlands', isRightToLeft: false, isSupported: true },
  'sv': { code: 'sv', name: 'Swedish', nativeName: 'Svenska', isRightToLeft: false, isSupported: true },
  'da': { code: 'da', name: 'Danish', nativeName: 'Dansk', isRightToLeft: false, isSupported: true },
  'no': { code: 'no', name: 'Norwegian', nativeName: 'Norsk', isRightToLeft: false, isSupported: true },
  'fi': { code: 'fi', name: 'Finnish', nativeName: 'Suomi', isRightToLeft: false, isSupported: true },
};

/**
 * Common YouTube subtitle file formats
 */
export enum SubtitleFormat {
  VTT = 'vtt',     // WebVTT format
  SRT = 'srt',     // SubRip format  
  TTML = 'ttml',   // Timed Text Markup Language
  JSON3 = 'json3', // YouTube's JSON format
}

/**
 * Subtitle fetch options
 */
export interface SubtitleFetchOptions {
  readonly format: SubtitleFormat;
  readonly translationLanguage?: string;
  readonly includeTimestamps: boolean;
  readonly includeMetadata: boolean;
} 