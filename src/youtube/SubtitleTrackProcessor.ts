/**
 * YouTube Subtitle Track Processor
 * Converts raw YouTube captions data into normalized SubtitleTrack objects
 */

import {
  SubtitleTrack,
  YTCaptionTrackRaw,
  YTPlayerCaptions,
  SubtitleKind,
  LanguageInfo,
  YOUTUBE_LANGUAGE_MAP,
} from './types'

/**
 * Processor for converting YouTube subtitle data
 */
export class SubtitleTrackProcessor {
  /**
   * Process raw captions data into normalized subtitle tracks
   */
  static processSubtitleTracks(captionsData: YTPlayerCaptions): SubtitleTrack[] {
    try {
      console.log('[LinguaTube] Processing subtitle tracks...')

      const rawTracks = captionsData.playerCaptionsTracklistRenderer?.captionTracks

      if (!rawTracks || rawTracks.length === 0) {
        console.log('[LinguaTube] No caption tracks found')
        return []
      }

      const processedTracks: SubtitleTrack[] = []

      for (const rawTrack of rawTracks) {
        try {
          const track = this.processIndividualTrack(rawTrack)
          if (track) {
            processedTracks.push(track)
          }
        } catch (error) {
          console.warn('[LinguaTube] Failed to process track:', rawTrack, error)
        }
      }

      console.log(`[LinguaTube] Processed ${processedTracks.length} subtitle tracks`)
      return this.sortAndDeduplicate(processedTracks)
    } catch (error) {
      console.error('[LinguaTube] Subtitle track processing failed:', error)
      return []
    }
  }

  /**
   * Process a single raw caption track
   */
  private static processIndividualTrack(rawTrack: YTCaptionTrackRaw): SubtitleTrack | null {
    try {
      // Extract basic information
      const languageCode = this.normalizeLanguageCode(rawTrack.languageCode)
      const languageName = this.extractLanguageName(rawTrack)
      const baseUrl = rawTrack.baseUrl
      const vssId = rawTrack.vssId

      // Determine subtitle kind
      const kind = this.determineSubtitleKind(rawTrack)

      // Check if auto-generated
      const isAutoGenerated = this.checkIfAutoGenerated(rawTrack)

      // Check if translatable
      const isTranslatable = rawTrack.isTranslatable ?? false

      // Check if right-to-left
      const isRightToLeft = rawTrack.rtl ?? this.isRightToLeftLanguage(languageCode)

      // Generate unique ID
      const id = this.generateTrackId(languageCode, kind, vssId)

      return {
        id,
        languageCode,
        languageName,
        baseUrl,
        kind,
        isAutoGenerated,
        isTranslatable,
        isRightToLeft,
        vssId,
        confidence: isAutoGenerated ? this.estimateConfidence(rawTrack) : undefined,
      }
    } catch (error) {
      console.error('[LinguaTube] Failed to process individual track:', error)
      return null
    }
  }

  /**
   * Normalize YouTube language codes to ISO 639-1 format
   */
  private static normalizeLanguageCode(code: string): string {
    // YouTube sometimes uses region-specific codes like 'en-US'
    const baseCode = code.split('-')[0].toLowerCase()

    // Handle special cases
    const codeMap: Record<string, string> = {
      iw: 'he', // Hebrew
      in: 'id', // Indonesian
      ji: 'yi', // Yiddish
      jw: 'jv', // Javanese
      mo: 'ro', // Moldovan -> Romanian
      sh: 'sr', // Serbo-Croatian -> Serbian
      tl: 'fil', // Tagalog -> Filipino
    }

    return codeMap[baseCode] || baseCode
  }

  /**
   * Extract human-readable language name
   */
  private static extractLanguageName(rawTrack: YTCaptionTrackRaw): string {
    try {
      // Try to get from the track's name field
      if (rawTrack.name.simpleText) {
        return rawTrack.name.simpleText
      }

      // Try to concatenate from runs
      if (rawTrack.name.runs && rawTrack.name.runs.length > 0) {
        return rawTrack.name.runs.map((run) => run.text).join('')
      }

      // Fallback to language map
      const languageCode = this.normalizeLanguageCode(rawTrack.languageCode)
      const languageInfo = YOUTUBE_LANGUAGE_MAP[languageCode]
      if (languageInfo) {
        return languageInfo.name
      }

      // Final fallback to language code
      return languageCode.toUpperCase()
    } catch (error) {
      console.warn('[LinguaTube] Failed to extract language name:', error)
      return rawTrack.languageCode
    }
  }

  /**
   * Determine the subtitle kind from raw track data
   */
  private static determineSubtitleKind(rawTrack: YTCaptionTrackRaw): SubtitleKind {
    const kind = rawTrack.kind?.toLowerCase()

    // Auto-generated tracks
    if (kind === 'asr' || this.checkIfAutoGenerated(rawTrack)) {
      return SubtitleKind.ASR
    }

    // Standard captions
    if (kind === 'captions' || !kind) {
      return SubtitleKind.CAPTIONS
    }

    // Forced subtitles (for foreign language parts)
    if (kind === 'forced') {
      return SubtitleKind.FORCED
    }

    // Unknown kind
    return SubtitleKind.UNKNOWN
  }

  /**
   * Check if a track is auto-generated
   */
  private static checkIfAutoGenerated(rawTrack: YTCaptionTrackRaw): boolean {
    // Check the kind field
    if (rawTrack.kind === 'asr') {
      return true
    }

    // Check the track name for auto-generated indicators
    const name =
      rawTrack.name.simpleText || rawTrack.name.runs?.map((run) => run.text).join('') || ''

    const autoGeneratedIndicators = [
      'auto-generated',
      'automatic captions',
      'autogenerated',
      'auto captions',
      '(auto-generated)',
      'auto',
      'automatic',
    ]

    const lowerName = name.toLowerCase()
    return autoGeneratedIndicators.some((indicator) => lowerName.includes(indicator))
  }

  /**
   * Check if a language is right-to-left
   */
  private static isRightToLeftLanguage(languageCode: string): boolean {
    const rtlLanguages = ['ar', 'he', 'fa', 'ur', 'ku', 'yi']
    return rtlLanguages.includes(languageCode)
  }

  /**
   * Generate a unique ID for a subtitle track
   */
  private static generateTrackId(languageCode: string, kind: SubtitleKind, vssId: string): string {
    const kindPrefix = {
      [SubtitleKind.CAPTIONS]: 'cap',
      [SubtitleKind.ASR]: 'asr',
      [SubtitleKind.FORCED]: 'forced',
      [SubtitleKind.UNKNOWN]: 'unknown',
    }[kind]

    // Create a shorter unique identifier
    const shortVssId = vssId.substring(0, 8)
    return `${kindPrefix}_${languageCode}_${shortVssId}`
  }

  /**
   * Estimate confidence for auto-generated tracks
   */
  private static estimateConfidence(rawTrack: YTCaptionTrackRaw): number {
    // This is a heuristic - in practice, YouTube doesn't provide confidence scores
    // We base this on language and track characteristics

    const languageCode = this.normalizeLanguageCode(rawTrack.languageCode)

    // High confidence languages (major languages with good ASR)
    const highConfidenceLanguages = ['en', 'es', 'fr', 'de', 'ja', 'ko', 'zh']
    if (highConfidenceLanguages.includes(languageCode)) {
      return 0.85
    }

    // Medium confidence languages
    const mediumConfidenceLanguages = ['it', 'pt', 'ru', 'ar', 'hi', 'tr']
    if (mediumConfidenceLanguages.includes(languageCode)) {
      return 0.75
    }

    // Lower confidence for less common languages
    return 0.65
  }

  /**
   * Sort tracks by preference and remove duplicates
   */
  private static sortAndDeduplicate(tracks: SubtitleTrack[]): SubtitleTrack[] {
    // Remove duplicates based on language code and kind
    const uniqueTracks = new Map<string, SubtitleTrack>()

    for (const track of tracks) {
      const key = `${track.languageCode}_${track.kind}`

      // Prefer manual captions over auto-generated for the same language
      const existing = uniqueTracks.get(key)
      if (!existing || (existing.isAutoGenerated && !track.isAutoGenerated)) {
        uniqueTracks.set(key, track)
      }
    }

    // Sort by preference: manual captions first, then by language preference
    const sortedTracks = Array.from(uniqueTracks.values()).sort((a, b) => {
      // Manual captions first
      if (a.isAutoGenerated !== b.isAutoGenerated) {
        return a.isAutoGenerated ? 1 : -1
      }

      // Standard captions before ASR
      if (a.kind !== b.kind) {
        const kindOrder = {
          [SubtitleKind.CAPTIONS]: 0,
          [SubtitleKind.FORCED]: 1,
          [SubtitleKind.ASR]: 2,
          [SubtitleKind.UNKNOWN]: 3,
        }
        return kindOrder[a.kind] - kindOrder[b.kind]
      }

      // Alphabetical by language name
      return a.languageName.localeCompare(b.languageName)
    })

    return sortedTracks
  }

  /**
   * Get language information for processed tracks
   */
  static getLanguageInfo(tracks: SubtitleTrack[]): LanguageInfo[] {
    const languageMap = new Map<string, LanguageInfo>()

    for (const track of tracks) {
      if (!languageMap.has(track.languageCode)) {
        const langInfo = YOUTUBE_LANGUAGE_MAP[track.languageCode] || {
          code: track.languageCode,
          name: track.languageName,
          isRightToLeft: track.isRightToLeft,
          isSupported: false, // Unknown language not in our map
        }

        languageMap.set(track.languageCode, langInfo)
      }
    }

    return Array.from(languageMap.values()).sort((a, b) => a.name.localeCompare(b.name))
  }

  /**
   * Filter tracks by criteria
   */
  static filterTracks(
    tracks: SubtitleTrack[],
    options: {
      includeAutoGenerated?: boolean
      includeTranslatable?: boolean
      languageCodes?: string[]
      kinds?: SubtitleKind[]
    } = {},
  ): SubtitleTrack[] {
    return tracks.filter((track) => {
      // Filter by auto-generated
      if (options.includeAutoGenerated === false && track.isAutoGenerated) {
        return false
      }

      // Filter by translatable
      if (options.includeTranslatable === false && track.isTranslatable) {
        return false
      }

      // Filter by language codes
      if (options.languageCodes && !options.languageCodes.includes(track.languageCode)) {
        return false
      }

      // Filter by kinds
      if (options.kinds && !options.kinds.includes(track.kind)) {
        return false
      }

      return true
    })
  }

  /**
   * Find best track by language preference
   */
  static findBestTrack(
    tracks: SubtitleTrack[],
    preferredLanguages: string[],
    preferManual = true,
  ): SubtitleTrack | null {
    if (tracks.length === 0) {
      return null
    }

    // Try each preferred language in order
    for (const langCode of preferredLanguages) {
      const languageTracks = tracks.filter((track) => track.languageCode === langCode)

      if (languageTracks.length > 0) {
        // Prefer manual captions if requested
        if (preferManual) {
          const manualTrack = languageTracks.find((track) => !track.isAutoGenerated)
          if (manualTrack) {
            return manualTrack
          }
        }

        // Return the first available track for this language
        return languageTracks[0]
      }
    }

    // Fallback to the first available track
    if (preferManual) {
      const manualTrack = tracks.find((track) => !track.isAutoGenerated)
      if (manualTrack) {
        return manualTrack
      }
    }

    return tracks[0]
  }
}
